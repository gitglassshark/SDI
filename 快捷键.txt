C+S,X		类向导 		
C+S,C 		类视图
添加新项 	C+S,A
Ctrl + Shift + B = 生成项目
Ctrl + Alt + L = 显示 Solution Explorer（解决方案资源管理器）
Shift + Alt+ C = 添加新类
Shift + Alt + A = 添加新项目到项目
Ctrl+J / Ctrl+K,L: 列出成员
CTRL + SHIFT + E显示资源视图
Shift+Alt+箭头键: 选择矩形文本
Alt+鼠标左按钮: 选择矩形文本
CTRL + W选择当前单词
查找		CSF
新建		CSN
打开		CSO
断点		CAB
输出 		CAO
F12: 转到所调用过程或变量的定义
F5: 启动调试
编译  	 	C+F7
Ctrl+F5: 开始执行(不调试)
Shift+F5: 停止调试
Ctrl+Shift+F5: 重启调试
Ctrl+Shift+F9: 删除全部断点
Ctrl+F10: 运行到光标处
逐过程  		F10
逐语句  		F11
Shift+F11 跳出
CK,CT    查看调用层次
C+K,C+F 	选定格式化
Ctrl + K，Ctrl + D = 正确对齐所有代码
POWERSHELL 	 C+`
保存		C+S
保存ALL		C+S,S
Ctrl+Shift+U: 全部变为大写
Ctrl+U: 全部变为小写
Ctrl + K，Ctrl + C = 注释选定行
Ctrl + K，Ctrl + U = 取消选定行的注释


2. 编辑相关的键盘快捷键

Ctrl + Enter = 在当前行插入空行
Ctrl + Shift + Enter = 在当前行下方插入空行
Ctrl + 空格键 = 使用 IntelliSense（智能感知）自动完成
Alt + Shift + 箭头键(←,↑,↓,→) = 选择代码的自定义部分
Ctrl + } = 匹配大括号、括号
Ctrl + Shift +} = 在匹配的括号、括号内选择文本
Ctrl + Shift + S = 保存所有文件和项目
Shift + End = 从头到尾选择整行
Shift + Home = 从尾到头选择整行
Ctrl+ Delete = 删除光标右侧的所有字
3. 导航相关的键盘快捷键

Ctrl +Up/Down = 滚动窗口但不移动光标
Ctrl + - = 让光标移动到它先前的位置
Ctrl ++ = 让光标移动到下一个位置

Ctrl + Alt + P = 附加到进程
Shift + F5 = 停止调试
Ctrl + Alt + Q = 添加快捷匹配

Ctrl + K Ctrl + K = 将当前行添加书签
Ctrl + K Ctrl + N = 导航至下一个书签
Ctrl + . = 如果你键入一个类名如 Collection，且命名空间导入不正确的话，那么这个快捷方式组合将自动插入导入
Ctrl + Shift + F = 在文件中查找
Shift + F12 = 查找所有引用
Ctrl + F = 显示查找对话框
Ctrl + H = 显示替换对话框
Ctrl + G = 跳转到行号或行
Ctrl + Shift + F = 查找所选条目在整个解决方案中的引用
6. 窗口操作快捷键

Ctrl+W,W: 浏览器窗口
Ctrl+W,S: 解决方案管理器
Ctrl+W,C: 类视图
Ctrl+W,E: 错误列表
Ctrl+W,O: 输出视图
Ctrl+W,P: 属性窗口
Ctrl+W,T: 任务列表
Ctrl+W,X: 工具箱
Ctrl+W,B: 书签窗口
Ctrl+W,U: 文档大纲
Ctrl+D,B: 断点窗口
Ctrl+D,I: 即时窗口
Ctrl+Tab: 活动窗体切换
Ctrl+Shift+N: 新建项目
Ctrl+Shift+O: 打开项目
Ctrl+Shift+S: 全部保存
Shift+Alt+C: 新建类
Ctrl+Shift+A: 新建项
7. 项目快捷键

CTRL + SHIFT + B生成解决方案
CTRL + F7 生成编译
CTRL + O 打开文件
CTRL + SHIFT + O打开项目
CTRL + SHIFT + C显示类视图窗口
F4 显示属性窗口
SHIFT + F4显示项目属性窗口
F12 转到定义
CTRL + F12c
CTRL + ALT + J对象浏览
CTRL + ALT + F1帮助目录
CTRL + F1 动态帮助
F1 帮助
SHIFT + F1当前窗口帮助
CTRL + ALT + F3帮助-搜索
SHIFT + ALT + ENTER全屏显示
CTRL + -向后定位
CTRL + SHIFT + -向前定位
CTRL + F4关闭文档窗口
CTRL + PAGE DOWN光标定位到窗口上方
CTRL + PAGE UP光标定位到窗口下方
CTRL + F6
CTRL + TAB下一个文档窗口
CTRL + SHIFT + F6
CTRL + SHIFT + TAB上一个文档窗口
ALT + F6下一个面板窗口
CTRL + K, CTRL + L取消remark
CTRL + M, CTRL + O折叠代码定义
CTRL + M, CTRL + L展开代码定义
CTRL + DELETE删除至词尾
CTRL + BACKSPACE删除至词头
SHIFT + TAB取消制表符
CTRL + SHIFT + END选择至文档末尾
CTRL + SHIFT + HOME选择至文档末尾开始
SHIFT + END选择至行尾
SHIFT + HOME选择至行开始处
SHIFT + ALT + END垂直选择到最后尾
SHIFT + ALT + HOME垂直选择到最前面
CTRL + A全选

CTRL + SHIFT + PAGE UP选择至本页前面
CTRL + SHIFT + PAGE DOWN选择至本页后面
CTRL + END文档定位到最后
CTRL + HOME文档定位到最前
CTRL + G转到…
CTRL + K, CTRL + P上一个标签
CTRL + K, CTRL + N下一个标签
ALT + F10调试-ApplyCodeChanges
CTRL + ALT+ Break停止调试
CTRL + SHIFT + F9 取消所有断点
CTRL + F9允许中断
CTRL + SHIFT + F5调试-重新开始
CTRL + J列出成员
CTRL + PAGE DOWN下一个视图
CTRL + B格式-粗体
CTRL + SHIFT + T格式-文字缩进
8. 调试快捷键

F6: 生成解决方案
Ctrl+F6: 生成当前项目
F7: 查看代码
Shift+F7: 查看窗体设计器
Ctrl+F5: 开始执行(不调试)
Shift+F5: 停止调试
Ctrl+Shift+F5: 重启调试
Ctrl+F9: 启用/停止断点
Ctrl+Shift+F9: 删除全部断点
F10: 逐过程
Ctrl+F10: 运行到光标处
F11: 逐语句
9. 编辑快捷键

Ctrl+E,D ----格式化全部代码
Ctrl+E,F ----格式化选中的代码
Shift+Alt+Enter: 切换全屏编辑
Ctrl+B,T / Ctrl+K,K: 切换书签开关
Ctrl+B,N / Ctrl+K,N: 移动到下一书签
Ctrl+B,P: 移动到上一书签
Ctrl+B,C: 清除全部标签
Ctrl+I: 渐进式搜索
Ctrl+Shift+I: 反向渐进式搜索
Ctrl+F: 查找
Ctrl+Shift+F: 在文件中查找
F3: 查找下一个
Shift+F3: 查找上一个
Ctrl+H: 替换
Ctrl+Shift+H: 在文件中替换
Alt+F12: 查找符号(列出所有查找结果)
Ctrl+Shift+V: 剪贴板循环
Ctrl+左右箭头键: 一次可以移动一个单词
Ctrl+上下箭头键: 滚动代码屏幕，但不移动光标位置。
Ctrl+Shift+L: 删除当前行
Ctrl+M,M: 隐藏或展开当前嵌套的折叠状态
Ctrl+M,L: 将所有过程设置为相同的隐藏或展开状态
Ctrl+M,P: 停止大纲显示
Ctrl+E,S: 查看空白
Ctrl+E,W: 自动换行
Ctrl+G: 转到指定行
10. 代码快捷键

Ctrl+Shift+空格键 / Ctrl+K,P: 参数信息
Ctrl+K,I: 快速信息
Ctrl+K,M: 生成方法存根
Ctrl+K,X: 插入代码段
Ctrl+K,S: 插入外侧代码
F12: 转到所调用过程或变量的定义
11. 单元测试

Ctrl + R , A : 执行所有测试
Ctrl + R , T : 执行当前所在测试方法
Ctrl + R , D: 执行最后一次测试的所有测试
Ctrl + R , F: 执行最后一次测试的所有测试的失败测试
//VsVim使用教程（以及简要vim介绍）
1. 配置快捷键
1.四种模式：normal,insert,visual,command
2.映射
   map:imap,nmap,vmap,cmap
   noremap:inoremap,nnoremap,vnoremap,cnoremap
3.Visual Studio 快捷键
    0.VsVim配置
        Optins->VsVim->
        Defaults:Use Editor Command Margin->False (否则，有命令框)
        Keyboard:set your Keyboard ->include All Scopes
    1.VsVimrc路径
        home下，_vsvimrc
    2.Vs命令查看方式：
        英语环境
        Tools->Options->Environment->Keyboard
        View->OtherWindow->Command Window
    3.在vim中调用快捷命令
        :vsc VAssistX.OpenFileInSolutionDialog<cr>
2.vim的常用命令
1.normal模式下
    1.移动
        .基本移动
            hjkl
            j:下
            k:上
            h:左
            l:右
        .单词移动
            w:word  "跳转到单词的头"
            W:WORD
            e:word's end   "跳转到单词的结尾"
            E:WORD's end
            ge:word's end "跳转到上一个单词的结尾"
            gE:WORD's end
            b:back "跳转到单词的头"
            B:back "跳转到WORD的头"
        .行移动
            _： 跳转到行的第一个字符
            0:  跳转到行首
            $:  跳转到行的最后一个字符
        .缩进行
            >> :向右缩进
            << :向左缩进
        .段落移动：
            {: 向上移动一个段落
            }: 向下移动一个段落
            [[:
            ]]:
            {[:
            }]:
        .屏幕移动
            gg: 跳转到文件首部
            G:  跳转到文件结尾
            12gg:   跳转到第12行
            zz: 当前光标移动到屏幕最中央
            zt: 当前光标移动到屏幕最上方（top）
            zb: 当前光标移动到屏幕最下方（bottom）
            c-f:    下翻半页
            c-u:    上翻半页
    2.进入插入模式
        i:  插入到光标前
        I:  插入到行的最前面
        a:  插入到光标后
        A:  插入到行的最后面
        s:删除光标下的字符，并进入插入模式
        S:删除当前行所有字符，并进入插入模式
        ce/cw: 删除当前光标到word末尾处的字符，进入插入模式
        C:删除当前光标后的所有字符，并进入插入模式

        o:插入到下一行
        O:插入到上一行
    3.撤销和reDo
        u:  撤销
        c-r: redo
    4.替换
        r:  用输入替换光标下的字符
        R:进入替换模式
    5.查找：
        .单行
        f{char}:    从当前光标向后查找char。
        F{char}:    从当前光标向前查找char
        t{char}:    从当前光标向后查找char,光标落到char之前
        T{char}:    从当前光标向前查找char,光标落到char之后
            ; :下一个char
            , :上一个char
        .整个文件中查找
        / : 从当前行向下查找
        ? : 从当前行向上查找
        * : 从当前向下，查找当前光标下的word 
        # : 从当前向上，查找当前光标下的word 
        n : 下一个查找结果
        N : 上一个查找结果
    6.删除
        x:剪切当前光标下的字符
        X:剪切当前光标前的一个字符

        d{motion}:删除
        dl: 删除当前光标下的一个字符
        de/dw: 删除当前光标下到word end的字符
        db: 删除当前光标下，到word head的字符
        D:  删除当前光标下到行尾的字符
    7.复制
        y{motion}:复制
        yl: 复制当前光标下的一个字符
        yy/Y：复制当前行
        ye/yw: 复制当前光标到word end的字符
        yb:复制当前光标前一字符到word head的字符
    8.粘贴
        p:粘贴到当前光标后
        P:粘贴到当前光标前

    9.点范式（.）
        . :重复上次的修改(移动，删除，增加)
    10.组合命令
        yyp:复制当前行到下一行
        ddp:和下一行交换（删除当前行，复制到下一行）
        xp:交换两个chr的位置

        yi(:复制括号()中的内容 yi{ yi[ yi" yi'
        di(:删除括号()中的内容 di{ di[ di" di'
        %:跳转匹配的{}、()、[]
    11.修改文本
       J:将光标所在的下一行和本行连接,并且中间隔一个空格
       gJ:将光标所在的下一行和本行连接(下一行的空格也连接)


2.insert模式下
    c-o:暂时进入normal模式。一次命令后，回到插入模式。


3.visual模式(visual(可视行，可视块))）,select(选择))
    normal模式进入可视模式：
        v:字符可视模式
        V:行visual
        c-v:块visual
    退出可视模式：
        行/块visual  v-> visual v-> normal
        字符可视模式  v ->normal
        <esc> or <c-[>
    块模式下插入：
        c-V：进入块模式，并选择好区域
        I    在所选区域前，进入块插入模式(插入的内容会在所有列都插入)
        A    在所选区域后，进入块插入模式(插入的内容会在所有列都插入)
        c    删除所选区域内容，并进入块插入模式(插入的内容会在所有列都插入)
        C    删除所选区域以及所选区域后的所有内容，并且进入块插入模式(插入的内容会在所有列都插入)
        <esc> 退出到normal模式

    c-g:切换可视模式和选择模式

    可用命令：
        移动：hjkl
        查找：f{char} ; , n/N
        删除：c C d x s
    其他命令：
        o: 切换选中区域的首和尾
        U: 选中的字符全部大写 
        u: 选中的字符全部小写
        ~：选中的字符切换大小写

    组合命令：
    ve/vw/viw:选中一个单词
    vu:光标下的字符小写
    vU:光标下的字符大写
    veu/U:选中一个单词小写/大写


4.command模式
    在normal模式或者visual模式下输入冒号:,进入命令模式
    normal模式下的命令，可以在命令模式下运行
    command下也可以运行ex命令
    :com[mand]  列出所有用户自定义的命令
    基本命令：
    :w[a]  [全部]写入（保存） 
    :q[a]  [全部]退出        
    :c[a]  [全部]关闭buffer
    :x[a]  [全部]和:wq类型，当文件有修改时候，会写入

    :[range]copy/co/t {address}  将范围内的行复制到目标地址处  {address}使用符号
    :[range]move {address}    将范围内的行移动到目标地址处

    :normal 命令，在命令行中执行normal模式下的命令
    如果是visual模式，会呈现
    :'<,'>normal    会在每一行都执行命令


5.命令范围
    .command模式下
        vim中，在单个文件中，
        1.以行号为地址
        2.此外，还有一些特殊符号表示地址，例如：
            %   整个文件（:1,$的简写形式）
            .   光标所在位置。当前位置
            1   文件第一行
            $   文件最后一行
            0   虚拟行，位于文件第一行上方
            'm  包含标记m的行
            '<  高亮选区的起始行
            '>  高亮选区的结束行

        范围的表示用逗号隔开，例如 add1,add2
        :12,15d 表示删除12行到15行内容
        :[range]d[elete] [x] {count}    "x到代表寄存器x里"
    .normal模式下
        normal中的一些命令，可以指定运行次数，例如：
            2dd 运行两次dd->删除两行
            2yy 运行两个yy->复制两行
3.mark和跳转
mx:添加本文件"书签"x
mX:添加全局"书签"X
`x:跳转到书签x所在的行和列
'x:跳转到书签x所在行
``:跳转到本文件上次离开的位置
gi:跳转到上一次插入的位置
gv:跳转到上一次进入visual的位置
4.VsVim的配置
1.重要配置
    set backspace=indent,eol,start "退格键设置"
    set clipboard=unnamed   "默认的剪切寄存器"
    set ignorecase  "忽略大小写"
2.推荐配置
    1.注释
        :vnoremap ci :s/^/\/\/<cr>
        :vnoremap cu :s/\/\//<cr>
        :nnoremap ci :s/^/\/\/<cr>
        :nnoremap cu :s/\/\//<cr>
    2.相关配置
        .单个文件中：
        :inoremap jj <esc>  "退出插入模式"
        :noremap gd <c-]>zz "跳转到定义"
        :nnoremap gq ==     "代码格式format"
        :vnoremap gq ==
        :nnoremap <space> za "折叠"
        :nnoremap zm :vsc VAssistX.ListMethodsInCurrentFile<cr> "函数列表"
        :nnoremap cj :vsc VAssistX.FindReferencesinFile<CR> "当前文件中的引用"
        :nnoremap ca :vsc VAssistX.FindReferences<CR> "查看所有引用"
        :nnoremap cm :vsc File.OpenContainingFolder<CR> "打开所在文件夹"
        :nnoremap zj :vsc Edit.QuickInfo<CR> "查看函数定义文档"
        :nnoremap zp :vsc VAssistX.RefactorImplementInterface<CR> "实现接口"

        "visual模式中的查找"
        :vnoremap * "/y/<C-r>/<CR>
        :vnoremap # "/y?<C-r>/<CR>

        .多文件
        :nnoremap <c-o> :vsc View.NavigateBackward<CR>  
        :nnoremap <c-i> :vsc View.NavigateForward<CR>

        "打开查看类的对话框
        :nnoremap cs :vsc VAssistX.FindSymbolDialog<CR>

        "打开查看文件的对话框
        :nnoremap cf :vsc VAssistX.OpenFileInSolutionDialog<CR>

        "open VAOutline
        :nnoremap co :vsc VAssistX.VAOutline<CR>

        "打开解决方案资源管理器
        :nnoremap cv :vsc View.SolutionExplorer<CR>

        "在文件中查找
        :nnoremap ck :vsc Edit.FindinFiles<CR>

        "end
3.配置文件
    source filefullPath     "读取filefullPath的配置内容，并运行"
5.寄存器介绍和使用
vim提供了几十组寄存器，用于保存文本
为命令添加 "{register}  表示指定要使用的寄存器。若不指定，将缺省用unnamed无名寄存器
     "x      表示引用了寄存器x

""      unnamed 无名寄存器,如果没有指定要使用的寄存器，vim会缺省使用此寄存器
"_      黑洞寄存器(实际上并没有存储，如果"_d{motion}会执行真正的删除)
"0      复制专用寄存器  (复制的时候，不仅会把内容拷贝到无名寄存器中，还会拷贝到此寄存器)
"a-"z   a-z寄存器(26个英文字母都是寄存器的名字)
"+      系统剪贴板寄存器 (使用"+p来粘贴系统剪贴板的内容)(X11剪切板，用剪切、复制与粘贴命令操作)
"*      选择专用寄存器 (X11主剪切板，用鼠标中断操作)
"=      表达式寄存器.在插入模式下c-r= ,会进入命令行模式，输入表达式回车之后的结果将插入文本中
"%      存储了当前文件名
"#      存储了轮换文件名
".      存储了上次插入的文本
":      存储了上次执行的Ex命令
"/      存储了上次查找的模式

使用示例：
"fyy    将复制的内容存储到f寄存器
"fp     将f寄存器中的内容粘贴出来

:reg[ister] "{register}     查看{register}中的内容
6.宏
把命令序列录制成宏
在normal,q键开始/停止录制宏。
开始录制：
    q{register} 表示指定将宏录制到哪个寄存器中
停止录制：
    再次按q,停止录制

@{register} 表示执行寄存器中的命令
@@  重复最近调用过的宏
[count]@{register}  执行count次宏       串行方式
:reg {register} 查看寄存器中的内容

追加：
    qa  录制按键操作，并覆盖a寄存器中原有内容
    qA  录制按键操作，并追加到a寄存器中
在插入模式中，插入寄存器中的内容：
c-r{register}   将寄存器中的内容插入到文本中
.多次执行宏：
    串行和并行。在处理错误的方式中，串行遇到错误，就返回。
    1.串行
        [count]@{register}
    2.并行
        :'<,'>normal @{register}
.迭代求值的方式给列编号
    使用了表达式寄存器(=)，以便插入的时候，可以进行运算
    (不要试图控制每次执行多少遍宏（vim 函数）)
    let i=0
    qa 0f[ls<c-r>=i<esc>j
    :let i+=1
    q
.编辑宏
    宏中使用的是键盘编码，
    如果使用<c-r>{register}的方式获取的寄存器内容不一样。
    不过，可以使用将寄存器中的内容粘贴出来的方式。
    1.输出到文本中编辑
        "{register}p        会粘贴到光标后,所以，用:put 输出到下一行
        :put {register}
        将寄存器内容输入到文本中
        编辑完成之后，
        "{register}dd       注意，Windows下，可能会将末尾的^M也粘贴进去。可以使用选中->删除到寄存器中
        将文本内容删除并读取到寄存器中
    2.使用函数
        :let @{register}=......
7.替换
:[range]s/{original}/{new}/[g]  g表示全部替换，否则只替换第一个遇到的
8.小技巧
1.
ctrl+h 删除前一个字符，相当于退格键
ctrl+w 删除前一个单词
ctrl+u 删除至行首
2.
num<C-a> :第一个遇到的数字加num 
num<C-x> :第一个遇到的数字减num 
tips:
:help [   index帮助文档中，所有命令
	vector<CAtlString> v;
	CAtlString csmessage;

	static CHAR CHAR64BIT[256] = { 0 };
	LONGLONG long64bit = 256 * 256 * 256 * 256 - 1;
	Long64ToChar(long64bit, CHAR64BIT);
	v.push_back(CAtlString(CHAR64BIT));
	dc << CAtlString(CHAR64BIT) << el;

	bitset<64> bit64a = 256;
	string sbitstr;

	sbitstr = bit64a.template to_string<char, char_traits<char>, allocator<char> >();

	CAtlString catstrbit32(sbitstr.c_str());
	v.push_back(CAtlString(catstrbit32));
	dc << catstrbit32 << el;

	bit64a = 256 * 256 * 256 * 256 * 256 * 256 * 256 * 256 - 1;
	sbitstr = bit64a.template to_string<char, char_traits<char>, allocator<char> >();
	v.push_back(CAtlString(sbitstr.c_str()));
	dc << CAtlString(sbitstr.c_str()) << el;

	dc.titleline(wstring(st(start test except catch try and throw...)));
	dc << typeid(catstrbit32).name() << el;

	for (auto& i : v) {
		position.y += step;
		dc << i << el;
		//COUTCS((dc), i);

       CAtlString csmessage;

	static CHAR CHAR64BIT[256] = { 0 };
	LONGLONG long64bit = 256 * 256 * 256 * 256 - 1;
	Long64ToChar(long64bit, CHAR64BIT);

	bitset<64> bit64a = this->m_int_decnum;
	string sbitstr;

	sbitstr = bit64a.template to_string<char, char_traits<char>, allocator<char> >();

	CAtlString catstrbit32(sbitstr.c_str());

